\section{Dokumentation af kode}

\subsubsection{Forklaring af Arv}
I programmeringssprog betyder nedarvning, at en klasse udvider en anden klasse, den kan altså bruge super klassens metoder. Dette gør det mere overskueligt at holde styr på sine forskellige klasser, og det gør det også nemmere, da man ikke skal skrive alle de nedarvede metoder igen, for hver subklasse man vil oprette. Et eksempel på en nedarvning, er et fartøj. Her vil det være muligt at lave forskellige nedarvninger på denne superklasse, f.eks. køretøj og luftfartøj. Man kan altså bruge nedarvning når ens subklasser har en relation til superklassen. Et andet eksempel, som vi gennemgik i klassen, er personer på DTU. Dette kan jo opdeles i mange subklasser, da vi både har studerende og ansatte, derudover har vi nogle undergrene til de ansatte, der specificerer præcist hvad for en ansat de er, og hvilke rettigheder de skal have til systemet, alt efter hvilken ansat de er. Her er nedarvning perfekt, da man slipper for at skrive meget af den samme kode igen.

\subsubsection{Forklaring af abstract}
En abstract klasse er en klasse hvor man tillader at der er metoder der ikke bliver implementeret, med dette menes der at disse metoder vil blive implementeret i subklasserne, således at den abstrakte klasse sender metoden videre til den klasse, der kan håndtere den information, den bliver kaldt på. Dette vil altså sige, at hvis man opretter en abstract metode, så skal denne metode også indgå i alle subklasserne. Et eksempel er her i vores CDIO3 rapport, benytter vi os bl.a. af en abstract metode, der hedder runAction. Denne abstrakte metode ligger i vores superklasse Field, når man så kalder runAction på et objekt 'field', så vil den sende denne metode videre til den respektive subklasse, hvis felt den blev kaldt på. Det vil altså sige, at hvis den bliver kaldt på et HouseField, så vil metoden runAction blive kørt som runAction metoden i HouseField, hvorimod hvis den bliver kaldt på et PrisonField, så vil metoden runAction blive kørt som runAction metoden i PrisonField. Dette gør koden meget nem overskuelig, og nem at videreudvikle på, da man bare kan gå ind i de respektive metoder man vil ændre.

\subsubsection{Fortæl hvad det hedder hvis alle fieldklasserne har en landOnField metode der gør noget forskelligt}
Dette ville være en abstract metode, ligesom den vi har beskrevet ovenfor. En sådan abstract metode vil ikke blive implementeret i superklassen, det vil altså sige, at superklassens metode vil blot lyde på 'public abstract void landOnField(parameter)', hvor parameteret kan være f.eks. en spiller eller et game objekt. Herefter ville man så override metoden til alle subklasserne, og herefter implementerer hvad hvert felt skal gøre. Dermed vil den, når man kalder metoden på et felt, sende metoden videre til den respektive subklasse, hvis felt den blev kaldt på.

\subsubsection{Dokumentation for overholdt GRASP}
GRASP er en række guidelines, man kan følge for at udvikle objektorienteret med bevidst klasseansvar. 
Den inddeler klasser i funktioner såsom controller (tager imod inputs fra spiller) og creator (skaber objekter) samt henviser til, at man skal opnå lav kobling og høj samhørighed.
\\
Vi følger til dels GRASP-modellen, idet vi har fordelt ansvaret i mange klasser, som hver har deres ansvarsområde ekslusivt vores \textit{Controller}, Game-klassen, som også agerer som \textit{Creator}.\\
En enkelt runde i køres som en metode playRound(), som er i en do-while-løkke, som kører, indtil en spiller er bankerot.

\subsubsection{Java-doc}
Vi bruger javadoc til at generere en dokumentation. Vores javadoc kan findes på \url{https://group-18.github.io/CDIO3/}, hvor næsten hver metode er blevet beskrevet.
Måden hvorpå en javadoc genereres i Java IDE er blevet illustreret forneden:
\begin{lstlisting}
/**
 * Get the balance of a player.
 *
 *@return the balance of the player.
 */
\end{lstlisting}